#include <errno.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef unsigned char INPUTMODE;
#define DEFAULT_MODE (INPUTMODE)0
#define SPECIAL_MODE (INPUTMODE)1
#define CHAR_MODE (INPUTMODE)2
#define MARKER_DEFINE_MODE (INPUTMODE)3
#define MARKER_JUMP_MODE (INPUTMODE)4

static void close_input(void);
static void output_indents(int);
static void output(const char* template, ...);
static void outputboilerplate_before(void);
static void outputboilerplate_after(void);
static int compile(FILE* input);
static INPUTMODE process_normal(char);
static void process_special(char);
static void process_char(char);
static void process_markerdefine(char, char* marker_information);
static void process_markerjump(char, char* marker_information);

bool errorhandler_defined;
int currentindent = 0;
FILE* input;

static void close_input(void)
{
    fclose(input);
}

static void output_indents(int amount)
{
    int current;
    for (current = 0; current < amount; current++) {
        printf("\t");
    }
}

static void output(const char* template, ...)
{
    va_list list;

    output_indents(currentindent);
    va_start(list, template);
    vprintf(template, list);
    va_end(list);
    printf("\n");
}

static void outputboilerplate_before(void)
{
    output("/* generated by bran */");
    output("#include <stdio.h>");
    output("");
    output("char buffer[1024];");
    output("");
    output("int main(void)");
    output("{");

    currentindent += 1;
    output("register unsigned int offset = 0;");
    output("unsigned int iregisters[8];   /* integer registers */");
    output("char* sregisters[8];          /* string registers (not null-terminated) */");
    output("unsigned char lregisters[8];  /* string length registers */");
}

static void outputboilerplate_after(void)
{
    output("\treturn 0;");
    output("}");
    output("/* eof */");
}

int main(int argc, char** argv)
{
    FILE* input = stdin;

    if (argc > 1)
        input = fopen(argv[1], "r");
    if (input == NULL) {
        perror(argv[0]);
        return 10 + errno;
    }

    atexit(close_input);
    return compile(input);
}

int compile(FILE* input)
{
    char current; /* stores the current character */
    INPUTMODE mode = DEFAULT_MODE; /* stores the current parser state */
    int marker[255]; /* stores the current version of each marker, to allow for duplicates */

    outputboilerplate_before();

    while ((current = fgetc(input)) != EOF) {
        switch (mode) {
        case DEFAULT_MODE:
            mode = process_normal(current);
            break;
        case SPECIAL_MODE:
            process_special(current);
            mode = DEFAULT_MODE;
            break;
        case CHAR_MODE:
            process_char(current);
            mode = DEFAULT_MODE;
            break;
        case MARKER_DEFINE_MODE:
            process_markerdefine(current, (char*)&marker);
            mode = DEFAULT_MODE;
            break;
        case MARKER_JUMP_MODE:
            process_markerjump(current, (char*)&marker);
            mode = DEFAULT_MODE;
            break;
        }
    }

    outputboilerplate_after();

    return EXIT_SUCCESS;
}

static INPUTMODE process_normal(char current)
{
    switch (current) {
    case '>':
        output("offset++;");
        break;
    case '<':
        output("offset--;");
        break;
    case '+':
        output("buffer[offset]++;");
        break;
    case '-':
        output("buffer[offset]--;");
        break;
    case '.':
        output("printf(\"%%c\", buffer[offset]);");
        break;
    case ',':
        output("buffer[offset] = getchar();");
        if (errorhandler_defined) {
            output("if (buffer[offset] == EOF) {");
            currentindent += 1;
            output("\tbuffer[offset] = errno;");
            output("\tgoto marker_E;");
            currentindent -= 1;
            output("}");
        } else {
            output("if (buffer[offset] == EOF) buffer[offset] = 0;");
        }

        break;
    case '[':
        output("while (buffer[offset] != 0)");
        output("{");
        currentindent += 1;
        break;
    case ']': {
        currentindent -= 1;
        output("} /* end while */");
        break;
    }
    case '$':
        return SPECIAL_MODE;
    case '%':
        output("printf(\"%%.*s\", lregisters['Z' - 'S'], sregisters['Z' - 'S']);");
        break;
    case '^':
        return MARKER_JUMP_MODE;
    case '*':
        return MARKER_DEFINE_MODE;
    case '\'':
        return CHAR_MODE;
    }

    return DEFAULT_MODE;
}

static void process_special(char current)
{
    if (current >= 'a' && current <= 'f') {
        output("iregisters['%c' - 'a'] = buffer[offset];", current);
    } else if (current >= 'A' && current <= 'F') {
        output("buffer[offset] = iregisters['%c' - 'A'];", current);
    } else if (current >= 's' && current <= 'z') {
        output("lregisters['%c' - 's'] = buffer[offset];", current);
        output("sregisters['%c' - 's'] = (&buffer[offset]) - buffer[offset];", current);
    } else if (current >= 'S' && current <= 'Z') {
        output("if (1) {");
        currentindent += 1;
        output("unsigned char len = lregisters['%c' - 'S'];", current);
        output("register unsigned char position;");
        output("for (position = 0; position < len; position++) buffer[offset - len + position] = sregisters['%c' - 'S'][position];", current - 'S');
        currentindent -= 1;
        output("} /* end scope */");
    }
}

static void process_char(char current)
{
    output("buffer[offset] = %d;", current);
}

static void process_markerjump(char current, char* marker_information)
{
    output("goto marker_%c_%d;", current, marker_information[(unsigned char)current]);
}

static void process_markerdefine(char current, char* marker_information)
{
    errorhandler_defined |= current == 'E';
    output("marker_%c_%d:", current, ++marker_information[(unsigned char)current]);
}
